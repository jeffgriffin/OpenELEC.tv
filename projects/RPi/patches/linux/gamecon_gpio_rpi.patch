diff -Naur a/drivers/input/joystick/gamecon.c b/drivers/input/joystick/gamecon.c
--- a/drivers/input/joystick/gamecon.c	2012-12-17 12:27:45.000000000 -0500
+++ b/drivers/input/joystick/gamecon.c	2013-01-28 01:37:49.999490376 -0500
@@ -1,13 +1,9 @@
 /*
- * NES, SNES, N64, MultiSystem, PSX gamepad driver for Linux
+ * NES, SNES, N64, PSX, Gamecube gamepad driver for Raspberry Pi
  *
- *  Copyright (c) 1999-2004	Vojtech Pavlik <vojtech@suse.cz>
- *  Copyright (c) 2004		Peter Nelson <rufus-kernel@hackish.org>
+ *  Copyright (c) 2012	Markus Hiienkari
  *
- *  Based on the work of:
- *	Andree Borrmann		John Dahlstrom
- *	David Kuder		Nathan Hand
- *	Raphael Assenat
+ *  Based on the gamecon driver by Vojtech Pavlik
  */
 
 /*
@@ -15,19 +11,16 @@
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- *
+ * 
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- *
+ * 
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
- *
- * Should you need to contact me, the author, you can do so either by
- * e-mail - mail your message to <vojtech@ucw.cz>, or by paper mail:
- * Vojtech Pavlik, Simunkova 1594, Prague 8, 182 00 Czech Republic
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
  */
 
 #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
@@ -36,31 +29,36 @@
 #include <linux/delay.h>
 #include <linux/module.h>
 #include <linux/init.h>
-#include <linux/parport.h>
 #include <linux/input.h>
 #include <linux/mutex.h>
 #include <linux/slab.h>
 
-MODULE_AUTHOR("Vojtech Pavlik <vojtech@ucw.cz>");
+#include <linux/ioport.h>
+#include <asm/io.h>
+
+MODULE_AUTHOR("Markus Hiienkari");
 MODULE_DESCRIPTION("NES, SNES, N64, MultiSystem, PSX gamepad driver");
 MODULE_LICENSE("GPL");
 
-#define GC_MAX_PORTS		3
-#define GC_MAX_DEVICES		5
+#define GC_MAX_DEVICES		6
+
+#define BCM2708_PERI_BASE        0x20000000
+#define GPIO_BASE                (BCM2708_PERI_BASE + 0x200000) /* GPIO controller */
+
+#define GPIO_SET *(gpio+7)
+#define GPIO_CLR *(gpio+10)
+
+static volatile unsigned *gpio;
 
 struct gc_config {
-	int args[GC_MAX_DEVICES + 1];
+	int args[GC_MAX_DEVICES];
 	unsigned int nargs;
 };
 
-static struct gc_config gc_cfg[GC_MAX_PORTS] __initdata;
+static struct gc_config gc_cfg __initdata;
 
-module_param_array_named(map, gc_cfg[0].args, int, &gc_cfg[0].nargs, 0);
-MODULE_PARM_DESC(map, "Describes first set of devices (<parport#>,<pad1>,<pad2>,..<pad5>)");
-module_param_array_named(map2, gc_cfg[1].args, int, &gc_cfg[1].nargs, 0);
-MODULE_PARM_DESC(map2, "Describes second set of devices");
-module_param_array_named(map3, gc_cfg[2].args, int, &gc_cfg[2].nargs, 0);
-MODULE_PARM_DESC(map3, "Describes third set of devices");
+module_param_array_named(map, gc_cfg.args, int, &(gc_cfg.nargs), 0);
+MODULE_PARM_DESC(map, "Describes the set of pad connections (<GPIO0>,<GPIO1>,<GPIO4>,<GPIO7>,<GPIO2>,<GPIO3>)");
 
 /* see also gs_psx_delay parameter in PSX support section */
 
@@ -68,7 +66,7 @@
 	GC_NONE = 0,
 	GC_SNES,
 	GC_NES,
-	GC_NES4,
+	GC_GCUBE,
 	GC_MULTI,
 	GC_MULTI2,
 	GC_N64,
@@ -86,8 +84,18 @@
 	char phys[32];
 };
 
+struct gc_nin_gpio {
+	unsigned pad_id;
+	unsigned cmd_setinputs;
+	unsigned cmd_setoutputs;
+	unsigned valid_bits;
+	unsigned request;
+	unsigned request_len;
+	unsigned response_len;
+	unsigned response_bufsize;
+};
+
 struct gc {
-	struct pardevice *pd;
 	struct gc_pad pads[GC_MAX_DEVICES];
 	struct timer_list timer;
 	int pad_count[GC_MAX];
@@ -99,12 +107,14 @@
 	unsigned int idx;
 };
 
-static struct gc *gc_base[3];
+static struct gc *gc_base;
 
-static const int gc_status_bit[] = { 0x40, 0x80, 0x20, 0x10, 0x08 };
+/* GPIO pins 0, 1, 4, 7, 2, 3 */
+static const int gc_status_bit[] = { 0x01, 0x02, 0x10, 0x80, 0x04, 0x08 };
+static const int gc_gpio_ids[] = { 0, 1, 4, 7, 2, 3 };
 
 static const char *gc_names[] = {
-	NULL, "SNES pad", "NES pad", "NES FourPort", "Multisystem joystick",
+	NULL, "SNES pad", "NES pad", "Gamecube controller", "Multisystem joystick",
 	"Multisystem 2-button joystick", "N64 controller", "PSX controller",
 	"PSX DDR controller", "SNES mouse"
 };
@@ -119,102 +129,121 @@
 	BTN_TL, BTN_TR, BTN_TRIGGER, BTN_START
 };
 
-#define GC_N64_LENGTH		32		/* N64 bit length, not including stop bit */
-#define GC_N64_STOP_LENGTH	5		/* Length of encoded stop bit */
-#define GC_N64_CMD_00		0x11111111UL
-#define GC_N64_CMD_01		0xd1111111UL
-#define GC_N64_CMD_03		0xdd111111UL
-#define GC_N64_CMD_1b		0xdd1dd111UL
-#define GC_N64_CMD_c0		0x111111ddUL
-#define GC_N64_CMD_80		0x1111111dUL
-#define GC_N64_STOP_BIT		0x1d		/* Encoded stop bit */
-#define GC_N64_REQUEST_DATA	GC_N64_CMD_01	/* the request data command */
-#define GC_N64_DELAY		133		/* delay between transmit request, and response ready (us) */
-#define GC_N64_DWS		3		/* delay between write segments (required for sound playback because of ISA DMA) */
-						/* GC_N64_DWS > 24 is known to fail */
-#define GC_N64_POWER_W		0xe2		/* power during write (transmit request) */
-#define GC_N64_POWER_R		0xfd		/* power during read */
-#define GC_N64_OUT		0x1d		/* output bits to the 4 pads */
-						/* Reading the main axes of any N64 pad is known to fail if the corresponding bit */
-						/* in GC_N64_OUT is pulled low on the output port (by any routine) for more */
-						/* than 123 us */
-#define GC_N64_CLOCK		0x02		/* clock bits for read */
+#define GC_N64_REQUEST_LENGTH   8               /* transmit request sequence is 8 bits long (without stop bit) */
+#define GC_N64_REQUEST          0x80U		 	/* the request data command */
 
-/*
- * Used for rumble code.
- */
+#define GC_N64_LENGTH			33				/* N64 response length, including stop bit */
 
-/* Send encoded command */
-static void gc_n64_send_command(struct gc *gc, unsigned long cmd,
-				unsigned char target)
-{
-	struct parport *port = gc->pd->port;
-	int i;
+/* buffer for samples read from pad */
+#define GC_N64_BUFSIZE		100*GC_N64_LENGTH
 
-	for (i = 0; i < GC_N64_LENGTH; i++) {
-		unsigned char data = (cmd >> i) & 1 ? target : 0;
-		parport_write_data(port, GC_N64_POWER_W | data);
-		udelay(GC_N64_DWS);
-	}
-}
+struct gc_nin_gpio n64_prop = { GC_N64,
+								0,
+								0,
+								0,
+								GC_N64_REQUEST,
+								GC_N64_REQUEST_LENGTH,
+								GC_N64_LENGTH,
+								GC_N64_BUFSIZE };
 
-/* Send stop bit */
-static void gc_n64_send_stop_bit(struct gc *gc, unsigned char target)
+/* Send encoded command */
+static inline void gc_n64_send_command(struct gc_nin_gpio *ningpio)
 {
-	struct parport *port = gc->pd->port;
 	int i;
-
-	for (i = 0; i < GC_N64_STOP_LENGTH; i++) {
-		unsigned char data = (GC_N64_STOP_BIT >> i) & 1 ? target : 0;
-		parport_write_data(port, GC_N64_POWER_W | data);
-		udelay(GC_N64_DWS);
+	
+	/* set correct GPIOs to outputs */
+	*gpio &= ~ningpio->cmd_setinputs;
+	*gpio |= ningpio->cmd_setoutputs;
+	
+	/* transmit a data request to pads */
+	for (i = 0; i < ningpio->request_len; i++) {
+		if ((unsigned)((ningpio->request >> i) & 1) == 0) {
+			GPIO_CLR = ningpio->valid_bits;
+			udelay(3);
+			GPIO_SET = ningpio->valid_bits;
+			udelay(1);
+		} else {
+			GPIO_CLR = ningpio->valid_bits;
+			udelay(1);
+			GPIO_SET = ningpio->valid_bits;
+			udelay(3);
+		}
 	}
+	
+	/* send stop bit (let pull-up handle the last 2us)*/
+	GPIO_CLR = ningpio->valid_bits;
+	udelay(1);
+	GPIO_SET = ningpio->valid_bits;
+	
+	/* set the GPIOs back to inputs */
+	*gpio &= ~ningpio->cmd_setinputs;
 }
 
 /*
- * gc_n64_read_packet() reads an N64 packet.
+ * gc_n64_read_packet() reads N64 or Gamecube packet.
  * Each pad uses one bit per byte. So all pads connected to this port
  * are read in parallel.
  */
 
-static void gc_n64_read_packet(struct gc *gc, unsigned char *data)
+static void gc_n64_read_packet(struct gc *gc, struct gc_nin_gpio *ningpio, unsigned char *data)
 {
-	int i;
+	int i,j,k;
+	unsigned prev, mindiff=1000, maxdiff=0;
 	unsigned long flags;
-
-/*
- * Request the pad to transmit data
- */
-
+	static unsigned char samplebuf[6500]; // =max(GC_N64_BUFSIZE, GC_GCUBE_BUFSIZE)
+	
+	/* disable interrupts */
 	local_irq_save(flags);
-	gc_n64_send_command(gc, GC_N64_REQUEST_DATA, GC_N64_OUT);
-	gc_n64_send_stop_bit(gc, GC_N64_OUT);
-	local_irq_restore(flags);
-
-/*
- * Wait for the pad response to be loaded into the 33-bit register
- * of the adapter.
- */
-
-	udelay(GC_N64_DELAY);
-
-/*
- * Grab data (ignoring the last bit, which is a stop bit)
- */
 
-	for (i = 0; i < GC_N64_LENGTH; i++) {
-		parport_write_data(gc->pd->port, GC_N64_POWER_R);
-		udelay(2);
-		data[i] = parport_read_status(gc->pd->port);
-		parport_write_data(gc->pd->port, GC_N64_POWER_R | GC_N64_CLOCK);
-	 }
+	gc_n64_send_command(ningpio);
+	
+	/* start sampling data */
+	for (i = 0; i < ningpio->response_bufsize; i++)
+		samplebuf[i] = *(gpio+13) & ningpio->valid_bits;
+	
+	/* enable interrupts when done */
+	local_irq_restore(flags);
+	
+	memset(data, 0x00, ningpio->response_len);
 
-/*
- * We must wait 200 ms here for the controller to reinitialize before
- * the next read request. No worries as long as gc_read is polled less
- * frequently than this.
- */
+	/* extract correct bit sequence (for each pad) from sampled data */
+	for (k = 0; k < GC_MAX_DEVICES; k++) {
+		if (gc->pads[k].type != ningpio->pad_id)
+			continue;
 
+		/* locate first falling edge */
+		for (i = 0; i < ningpio->response_bufsize; i++) {
+			if ((samplebuf[i] & gc_status_bit[k]) == 0)
+				break;
+		}
+		
+		prev = i;
+		j = 0;
+		
+		while (j < ningpio->response_len-1 && i < ningpio->response_bufsize-1) {
+			i++;
+			/* detect consecutive falling edges */
+			if ((samplebuf[i-1] & gc_status_bit[k]) != 0 && (samplebuf[i] & gc_status_bit[k]) == 0) {
+				/* update min&max diffs */
+				if (i-prev > maxdiff)
+					maxdiff = i - prev;
+				if (i-prev < mindiff)
+					mindiff = i - prev;
+
+				/* data is taken between 2 falling edges */
+				data[j] |= samplebuf[prev+((i-prev)/2)] & gc_status_bit[k];
+				j++;
+				prev = i;
+			}
+		}
+		
+		/* ignore the real stop-bit as it seems to be 0 at times. Invalidate
+		 * the read manually instead, if either of the following is true:
+		 * 		1. Less than response_len-1 bits read detected from samplebuf
+		 * 		2. Variation in falling edge intervals is too high */
+		if ((j == ningpio->response_len-1) && (maxdiff < 2*mindiff))
+			data[ningpio->response_len-1] |= gc_status_bit[k];
+	}
 }
 
 static void gc_n64_process_packet(struct gc *gc)
@@ -224,7 +253,7 @@
 	int i, j, s;
 	signed char x, y;
 
-	gc_n64_read_packet(gc, data);
+	gc_n64_read_packet(gc, &n64_prop, data);
 
 	for (i = 0; i < GC_MAX_DEVICES; i++) {
 
@@ -234,7 +263,8 @@
 		dev = gc->pads[i].dev;
 		s = gc_status_bit[i];
 
-		if (s & ~(data[8] | data[9])) {
+		/* ensure that the response is valid */
+		if (s & ~(data[8] | data[9] | ~data[32])) {
 
 			x = y = 0;
 
@@ -265,42 +295,6 @@
 static int gc_n64_play_effect(struct input_dev *dev, void *data,
 			      struct ff_effect *effect)
 {
-	int i;
-	unsigned long flags;
-	struct gc *gc = input_get_drvdata(dev);
-	struct gc_subdev *sdev = data;
-	unsigned char target = 1 << sdev->idx; /* select desired pin */
-
-	if (effect->type == FF_RUMBLE) {
-		struct ff_rumble_effect *rumble = &effect->u.rumble;
-		unsigned int cmd =
-			rumble->strong_magnitude || rumble->weak_magnitude ?
-			GC_N64_CMD_01 : GC_N64_CMD_00;
-
-		local_irq_save(flags);
-
-		/* Init Rumble - 0x03, 0x80, 0x01, (34)0x80 */
-		gc_n64_send_command(gc, GC_N64_CMD_03, target);
-		gc_n64_send_command(gc, GC_N64_CMD_80, target);
-		gc_n64_send_command(gc, GC_N64_CMD_01, target);
-		for (i = 0; i < 32; i++)
-			gc_n64_send_command(gc, GC_N64_CMD_80, target);
-		gc_n64_send_stop_bit(gc, target);
-
-		udelay(GC_N64_DELAY);
-
-		/* Now start or stop it - 0x03, 0xc0, 0zx1b, (32)0x01/0x00 */
-		gc_n64_send_command(gc, GC_N64_CMD_03, target);
-		gc_n64_send_command(gc, GC_N64_CMD_c0, target);
-		gc_n64_send_command(gc, GC_N64_CMD_1b, target);
-		for (i = 0; i < 32; i++)
-			gc_n64_send_command(gc, cmd, target);
-		gc_n64_send_stop_bit(gc, target);
-
-		local_irq_restore(flags);
-
-	}
-
 	return 0;
 }
 
@@ -326,6 +320,93 @@
 	return 0;
 }
 
+
+/*
+ * Gamecube support.
+ */
+
+static const unsigned char gc_gcube_bytes[] = { 7, 6, 5, 4, 11, 9, 10, 3 };
+static const short gc_gcube_btn[] = {
+	BTN_A, BTN_B, BTN_X, BTN_Y, BTN_Z,
+	BTN_TL, BTN_TR, BTN_START
+};
+
+#define GC_GCUBE_REQUEST_LENGTH   24            /* transmit request sequence is 24 bits long (without stop bit) */
+#define GC_GCUBE_REQUEST          0x40c002U 	/* the request data command */
+
+#define GC_GCUBE_LENGTH			  65			/* Gamecube response length, including stop bit */
+
+/* buffer for samples read from pad */
+#define GC_GCUBE_BUFSIZE		100*GC_GCUBE_LENGTH
+
+struct gc_nin_gpio gcube_prop = { GC_GCUBE,
+								0,
+								0,
+								0,
+								GC_GCUBE_REQUEST,
+								GC_GCUBE_REQUEST_LENGTH,
+								GC_GCUBE_LENGTH,
+								GC_GCUBE_BUFSIZE };
+
+static void gc_gcube_process_packet(struct gc *gc)
+{
+	unsigned char data[GC_GCUBE_LENGTH];
+	struct input_dev *dev;
+	int i, j, s;
+	unsigned char x, y, x2, y2, y3, y4;
+
+	gc_n64_read_packet(gc, &gcube_prop, data);
+
+	for (i = 0; i < GC_MAX_DEVICES; i++) {
+
+		if (gc->pads[i].type != GC_GCUBE)
+			continue;
+
+		dev = gc->pads[i].dev;
+		s = gc_status_bit[i];
+
+		/* ensure that the response is valid */
+		if (s & ~(data[0] | data[1] | ~data[8] | ~data[64])) {
+
+			x = y = x2 = y2 = y3 = y4 = 0;
+
+			for (j = 0; j < 8; j++) {
+				if (data[23 - j] & s)
+					x |= 1 << j;
+				if (data[31 - j] & s)
+					y |= 1 << j;
+				if (data[39 - j] & s)
+					x2 |= 1 << j;
+				if (data[47 - j] & s)
+					y2 |= 1 << j;
+				if (data[55 - j] & s)
+					y3 |= 1 << j;
+				if (data[63 - j] & s)
+					y4 |= 1 << j;					
+			}
+
+			input_report_abs(dev, ABS_X, x);
+			input_report_abs(dev, ABS_Y, 0xff - y);
+			input_report_abs(dev, ABS_RX, x2);
+			input_report_abs(dev, ABS_RY, 0xff - y2);
+			input_report_abs(dev, ABS_GAS, y3);
+			input_report_abs(dev, ABS_BRAKE, y4);			
+			
+			input_report_abs(dev, ABS_HAT0X,
+					 !(s & data[15]) - !(s & data[14]));
+			input_report_abs(dev, ABS_HAT0Y,
+					 !(s & data[12]) - !(s & data[13]));
+
+			for (j = 0; j < 8; j++)
+				input_report_key(dev, gc_gcube_btn[j],
+						 s & data[gc_gcube_bytes[j]]);
+
+			input_sync(dev);
+		}
+	}
+}
+
+
 /*
  * NES/SNES support.
  */
@@ -337,9 +418,9 @@
 #define GC_SNESMOUSE_LENGTH	32	/* The SNES mouse uses 32 bits, the first
 					   16 bits are equivalent to a gamepad */
 
-#define GC_NES_POWER	0xfc
-#define GC_NES_CLOCK	0x01
-#define GC_NES_LATCH	0x02
+/* clock = gpio10, latch = gpio11 */
+#define GC_NES_CLOCK	0x400
+#define GC_NES_LATCH	0x800
 
 static const unsigned char gc_nes_bytes[] = { 0, 1, 2, 3 };
 static const unsigned char gc_snes_bytes[] = { 8, 0, 2, 3, 9, 1, 10, 11 };
@@ -357,16 +438,16 @@
 {
 	int i;
 
-	parport_write_data(gc->pd->port, GC_NES_POWER | GC_NES_CLOCK | GC_NES_LATCH);
+	GPIO_SET = GC_NES_CLOCK | GC_NES_LATCH;
 	udelay(GC_NES_DELAY * 2);
-	parport_write_data(gc->pd->port, GC_NES_POWER | GC_NES_CLOCK);
+	GPIO_CLR = GC_NES_LATCH;
 
 	for (i = 0; i < length; i++) {
 		udelay(GC_NES_DELAY);
-		parport_write_data(gc->pd->port, GC_NES_POWER);
-		data[i] = parport_read_status(gc->pd->port) ^ 0x7f;
+		GPIO_CLR = GC_NES_CLOCK;
+		data[i] = ~(*(gpio+13));
 		udelay(GC_NES_DELAY);
-		parport_write_data(gc->pd->port, GC_NES_POWER | GC_NES_CLOCK);
+		GPIO_SET = GC_NES_CLOCK;
 	}
 }
 
@@ -462,62 +543,6 @@
 }
 
 /*
- * Multisystem joystick support
- */
-
-#define GC_MULTI_LENGTH		5	/* Multi system joystick packet length is 5 */
-#define GC_MULTI2_LENGTH	6	/* One more bit for one more button */
-
-/*
- * gc_multi_read_packet() reads a Multisystem joystick packet.
- */
-
-static void gc_multi_read_packet(struct gc *gc, int length, unsigned char *data)
-{
-	int i;
-
-	for (i = 0; i < length; i++) {
-		parport_write_data(gc->pd->port, ~(1 << i));
-		data[i] = parport_read_status(gc->pd->port) ^ 0x7f;
-	}
-}
-
-static void gc_multi_process_packet(struct gc *gc)
-{
-	unsigned char data[GC_MULTI2_LENGTH];
-	int data_len = gc->pad_count[GC_MULTI2] ? GC_MULTI2_LENGTH : GC_MULTI_LENGTH;
-	struct gc_pad *pad;
-	struct input_dev *dev;
-	int i, s;
-
-	gc_multi_read_packet(gc, data_len, data);
-
-	for (i = 0; i < GC_MAX_DEVICES; i++) {
-		pad = &gc->pads[i];
-		dev = pad->dev;
-		s = gc_status_bit[i];
-
-		switch (pad->type) {
-		case GC_MULTI2:
-			input_report_key(dev, BTN_THUMB, s & data[5]);
-			/* fall through */
-
-		case GC_MULTI:
-			input_report_abs(dev, ABS_X,
-					 !(s & data[2]) - !(s & data[3]));
-			input_report_abs(dev, ABS_Y,
-					 !(s & data[0]) - !(s & data[1]));
-			input_report_key(dev, BTN_TRIGGER, s & data[4]);
-			input_sync(dev);
-			break;
-
-		default:
-			break;
-		}
-	}
-}
-
-/*
  * PSX support
  *
  * See documentation at:
@@ -526,7 +551,7 @@
  *
  */
 
-#define GC_PSX_DELAY	25		/* 25 usec */
+#define GC_PSX_DELAY	10		/* 25 usec */
 #define GC_PSX_LENGTH	8		/* talk to the controller in bits */
 #define GC_PSX_BYTES	6		/* the maximum number of bytes to read off the controller */
 
@@ -536,10 +561,9 @@
 #define GC_PSX_ANALOG	5		/* Analog in Analog mode / Rumble in Green mode */
 #define GC_PSX_RUMBLE	7		/* Rumble in Red mode */
 
-#define GC_PSX_CLOCK	0x04		/* Pin 4 */
-#define GC_PSX_COMMAND	0x01		/* Pin 2 */
-#define GC_PSX_POWER	0xf8		/* Pins 5-9 */
-#define GC_PSX_SELECT	0x02		/* Pin 3 */
+#define GC_PSX_CLOCK	(1<<18)		/* Pin 18 */
+#define GC_PSX_COMMAND	(1<<14)		/* Pin 14 */
+#define GC_PSX_SELECT	(1<<15)		/* Pin 15 */
 
 #define GC_PSX_ID(x)	((x) >> 4)	/* High nibble is device type */
 #define GC_PSX_LEN(x)	(((x) & 0xf) << 1)	/* Low nibble is length in bytes/2 */
@@ -564,17 +588,22 @@
 
 static void gc_psx_command(struct gc *gc, int b, unsigned char *data)
 {
-	struct parport *port = gc->pd->port;
-	int i, j, cmd, read;
+	int i, j, read;
 
 	memset(data, 0, GC_MAX_DEVICES);
 
 	for (i = 0; i < GC_PSX_LENGTH; i++, b >>= 1) {
-		cmd = (b & 1) ? GC_PSX_COMMAND : 0;
-		parport_write_data(port, cmd | GC_PSX_POWER);
+		
+		if (b & 1)
+			GPIO_SET = GC_PSX_COMMAND;
+		else
+			GPIO_CLR = GC_PSX_COMMAND;
+		
+		GPIO_CLR = GC_PSX_CLOCK;
+		
 		udelay(gc_psx_delay);
 
-		read = parport_read_status(port) ^ 0x80;
+		read = *(gpio+13);
 
 		for (j = 0; j < GC_MAX_DEVICES; j++) {
 			struct gc_pad *pad = &gc->pads[j];
@@ -583,7 +612,8 @@
 				data[j] |= (read & gc_status_bit[j]) ? (1 << i) : 0;
 		}
 
-		parport_write_data(gc->pd->port, cmd | GC_PSX_CLOCK | GC_PSX_POWER);
+		GPIO_SET = GC_PSX_CLOCK;
+		
 		udelay(gc_psx_delay);
 	}
 }
@@ -602,10 +632,10 @@
 	unsigned char data2[GC_MAX_DEVICES];
 
 	/* Select pad */
-	parport_write_data(gc->pd->port, GC_PSX_CLOCK | GC_PSX_SELECT | GC_PSX_POWER);
+	GPIO_SET = GC_PSX_CLOCK | GC_PSX_SELECT;
 	udelay(gc_psx_delay);
 	/* Deselect, begin command */
-	parport_write_data(gc->pd->port, GC_PSX_CLOCK | GC_PSX_POWER);
+	GPIO_CLR = GC_PSX_SELECT;
 	udelay(gc_psx_delay);
 
 	local_irq_save(flags);
@@ -634,7 +664,7 @@
 
 	local_irq_restore(flags);
 
-	parport_write_data(gc->pd->port, GC_PSX_CLOCK | GC_PSX_SELECT | GC_PSX_POWER);
+	GPIO_SET = GC_PSX_CLOCK | GC_PSX_SELECT;
 
 	/* Set id's to the real value */
 	for (i = 0; i < GC_MAX_DEVICES; i++)
@@ -746,12 +776,15 @@
 	struct gc *gc = (void *) private;
 
 /*
- * N64 pads - must be read first, any read confuses them for 200 us
+ * N64 & Gamecube pads
  */
 
 	if (gc->pad_count[GC_N64])
 		gc_n64_process_packet(gc);
-
+		
+	if (gc->pad_count[GC_GCUBE])
+		gc_gcube_process_packet(gc);
+		
 /*
  * NES and SNES pads or mouse
  */
@@ -761,14 +794,7 @@
 	    gc->pad_count[GC_SNESMOUSE]) {
 		gc_nes_process_packet(gc);
 	}
-
-/*
- * Multi and Multi2 joysticks
- */
-
-	if (gc->pad_count[GC_MULTI] || gc->pad_count[GC_MULTI2])
-		gc_multi_process_packet(gc);
-
+	
 /*
  * PSX controllers
  */
@@ -788,11 +814,8 @@
 	if (err)
 		return err;
 
-	if (!gc->used++) {
-		parport_claim(gc->pd);
-		parport_write_control(gc->pd->port, 0x04);
+	if (!gc->used++)
 		mod_timer(&gc->timer, jiffies + GC_REFRESH_TIME);
-	}
 
 	mutex_unlock(&gc->mutex);
 	return 0;
@@ -805,8 +828,6 @@
 	mutex_lock(&gc->mutex);
 	if (!--gc->used) {
 		del_timer_sync(&gc->timer);
-		parport_write_control(gc->pd->port, 0x00);
-		parport_release(gc->pd);
 	}
 	mutex_unlock(&gc->mutex);
 }
@@ -832,7 +853,7 @@
 	pad->type = pad_type;
 
 	snprintf(pad->phys, sizeof(pad->phys),
-		 "%s/input%d", gc->pd->port->name, idx);
+		 "input%d", idx);
 
 	input_dev->name = gc_names[pad_type];
 	input_dev->phys = pad->phys;
@@ -867,14 +888,37 @@
 			input_set_abs_params(input_dev, ABS_HAT0X + i, -1, 1, 0, 0);
 		}
 
-		err = gc_n64_init_ff(input_dev, idx);
+		/*err = gc_n64_init_ff(input_dev, idx);
 		if (err) {
 			pr_warning("Failed to initiate rumble for N64 device %d\n", idx);
 			goto err_free_dev;
-		}
+		}*/
+		
+		/* create bitvectors read/write operations */
+		n64_prop.cmd_setinputs |= (7<<(gc_gpio_ids[idx]*3));
+		n64_prop.cmd_setoutputs |= (1<<(gc_gpio_ids[idx]*3));
+		n64_prop.valid_bits |= gc_status_bit[idx];
 
 		break;
+		
+	case GC_GCUBE:
+		for (i = 0; i < 8; i++)
+			__set_bit(gc_gcube_btn[i], input_dev->keybit);
 
+		for (i = 0; i < 2; i++) {
+			input_set_abs_params(input_dev, ABS_X+i, 32, 223, 0, 10); //In theory, all axes operate from 0 to 255.  In practice, the plastic enclosure and other mechanical realities limit extremes and there is a great variance in achievable extremes and centers.  Values below are based on worst-case scenarios for extremes among a set of controllers.  -Jeff Griffin
+			input_set_abs_params(input_dev, ABS_RX+i, 50, 205, 0, 10);
+			input_set_abs_params(input_dev, ABS_GAS+i, -149, 222, 0, 10); // False bottom prevents negative gas/brake.  In practice,  min/center~35, max~222
+			input_set_abs_params(input_dev, ABS_HAT0X+i, -1, 1, 0, 0);
+		}
+
+		/* create bitvectors read/write operations */
+		gcube_prop.cmd_setinputs |= (7<<(gc_gpio_ids[idx]*3));
+		gcube_prop.cmd_setoutputs |= (1<<(gc_gpio_ids[idx]*3));
+		gcube_prop.valid_bits |= gc_status_bit[idx];
+
+		break;
+		
 	case GC_SNESMOUSE:
 		__set_bit(BTN_LEFT, input_dev->keybit);
 		__set_bit(BTN_RIGHT, input_dev->keybit);
@@ -889,13 +933,7 @@
 		for (i = 0; i < 4; i++)
 			__set_bit(gc_snes_btn[i], input_dev->keybit);
 		break;
-
-	case GC_MULTI2:
-		__set_bit(BTN_THUMB, input_dev->keybit);
-	case GC_MULTI:
-		__set_bit(BTN_TRIGGER, input_dev->keybit);
-		break;
-
+		
 	case GC_PSX:
 		for (i = 0; i < 6; i++)
 			input_set_abs_params(input_dev,
@@ -917,6 +955,22 @@
 	err = input_register_device(pad->dev);
 	if (err)
 		goto err_free_dev;
+		
+				
+	/* set data pin to input */
+	*gpio &= ~(7<<(gc_gpio_ids[idx]*3));
+	
+	/* enable pull-up on GPIO4 / GPIO7 */
+	if ((idx > 1) && (idx < 4)) {
+		*(gpio+37) = 0x02;
+		udelay(10);
+		*(gpio+38) = (1 << gc_gpio_ids[idx]);
+		udelay(10);
+		*(gpio+37) = 0x00;
+		*(gpio+38) = 0x00;
+	}
+		
+	printk("%s data pin connected to GPIO%d\n", gc_names[pad_type], gc_gpio_ids[idx]);
 
 	return 0;
 
@@ -926,38 +980,21 @@
 	return err;
 }
 
-static struct gc __init *gc_probe(int parport, int *pads, int n_pads)
+static struct gc __init *gc_probe(int *pads, int n_pads)
 {
 	struct gc *gc;
-	struct parport *pp;
-	struct pardevice *pd;
 	int i;
 	int count = 0;
 	int err;
 
-	pp = parport_find_number(parport);
-	if (!pp) {
-		pr_err("no such parport %d\n", parport);
-		err = -EINVAL;
-		goto err_out;
-	}
-
-	pd = parport_register_device(pp, "gamecon", NULL, NULL, NULL, PARPORT_DEV_EXCL, NULL);
-	if (!pd) {
-		pr_err("parport busy already - lp.o loaded?\n");
-		err = -EBUSY;
-		goto err_put_pp;
-	}
-
 	gc = kzalloc(sizeof(struct gc), GFP_KERNEL);
 	if (!gc) {
 		pr_err("Not enough memory\n");
 		err = -ENOMEM;
-		goto err_unreg_pardev;
+		goto err_out;
 	}
 
 	mutex_init(&gc->mutex);
-	gc->pd = pd;
 	setup_timer(&gc->timer, gc_timer, (long) gc);
 
 	for (i = 0; i < n_pads && i < GC_MAX_DEVICES; i++) {
@@ -976,8 +1013,24 @@
 		err = -EINVAL;
 		goto err_free_gc;
 	}
+	
+	/* setup common pins for each pad type */
+	if (gc->pad_count[GC_NES] ||
+	    gc->pad_count[GC_SNES] ||
+	    gc->pad_count[GC_SNESMOUSE]) {
+		
+		/* set clk & latch pins to OUTPUT */
+		*(gpio+1) &= ~0x3f;
+		*(gpio+1) |= 0x09;
+	}
+	if (gc->pad_count[GC_PSX] ||
+		gc->pad_count[GC_DDR]) {
+	
+		/* set clk, cmd & sel pins to OUTPUT */
+		*(gpio+1) &= ~((7<<12) | (7<<15) | (7<<24));
+		*(gpio+1) |= ((1<<12) | (1<<15) | (1<<24));
+	}
 
-	parport_put_port(pp);
 	return gc;
 
  err_unreg_devs:
@@ -986,10 +1039,6 @@
 			input_unregister_device(gc->pads[i].dev);
  err_free_gc:
 	kfree(gc);
- err_unreg_pardev:
-	parport_unregister_device(pd);
- err_put_pp:
-	parport_put_port(pp);
  err_out:
 	return ERR_PTR(err);
 }
@@ -1001,53 +1050,38 @@
 	for (i = 0; i < GC_MAX_DEVICES; i++)
 		if (gc->pads[i].dev)
 			input_unregister_device(gc->pads[i].dev);
-	parport_unregister_device(gc->pd);
 	kfree(gc);
 }
 
 static int __init gc_init(void)
 {
-	int i;
-	int have_dev = 0;
-	int err = 0;
-
-	for (i = 0; i < GC_MAX_PORTS; i++) {
-		if (gc_cfg[i].nargs == 0 || gc_cfg[i].args[0] < 0)
-			continue;
-
-		if (gc_cfg[i].nargs < 2) {
-			pr_err("at least one device must be specified\n");
-			err = -EINVAL;
-			break;
-		}
-
-		gc_base[i] = gc_probe(gc_cfg[i].args[0],
-				      gc_cfg[i].args + 1, gc_cfg[i].nargs - 1);
-		if (IS_ERR(gc_base[i])) {
-			err = PTR_ERR(gc_base[i]);
-			break;
-		}
-
-		have_dev = 1;
-	}
+	/* Set up gpio pointer for direct register access */
+   	if ((gpio = ioremap(GPIO_BASE, 0xB0)) == NULL) {
+   	   	pr_err("io remap failed\n");
+   	   	return -EBUSY;
+   	}   	
 
-	if (err) {
-		while (--i >= 0)
-			if (gc_base[i])
-				gc_remove(gc_base[i]);
-		return err;
+	if (gc_cfg.nargs < 1) {
+		pr_err("at least one device must be specified\n");
+		return -EINVAL;
+	} else if ((gc_psx_delay < 1) || (gc_psx_delay > 50)) {
+		pr_err("Invalid psx_delay (1-50 allowed)\n");
+		return -EINVAL;
+	} else {
+		gc_base = gc_probe(gc_cfg.args, gc_cfg.nargs);
+		if (IS_ERR(gc_base))
+			return -ENODEV;
 	}
 
-	return have_dev ? 0 : -ENODEV;
+	return 0;
 }
 
 static void __exit gc_exit(void)
 {
-	int i;
-
-	for (i = 0; i < GC_MAX_PORTS; i++)
-		if (gc_base[i])
-			gc_remove(gc_base[i]);
+	if (gc_base)
+		gc_remove(gc_base);
+			
+	iounmap(gpio);
 }
 
 module_init(gc_init);
diff -Naur a/drivers/input/joystick/Kconfig b/drivers/input/joystick/Kconfig
--- a/drivers/input/joystick/Kconfig	2013-01-28 01:44:30.154465873 -0500
+++ b/drivers/input/joystick/Kconfig	2013-01-28 01:42:35.774762182 -0500
@@ -220,7 +220,6 @@
 
 config JOYSTICK_GAMECON
 	tristate "Multisystem, NES, SNES, N64, PSX joysticks and gamepads"
-	depends on PARPORT
 	select INPUT_FF_MEMLESS
 	---help---
 	  Say Y here if you have a Nintendo Entertainment System gamepad,
